// -*- text -*-
/**
 * \file Random.doc
 * \brief Documentation for Random, MT19937, SFMT19937, RandomSeed, etc.
 *
 * Written by Charles Karney <charles@karney.com> and licensed under the
 * LGPL.  For more information, see http://charles.karney.info/random/
 **********************************************************************/
// $Id: Random.doc 6403 2007-05-21 14:58:59Z ckarney $
/**
\mainpage Random number library
\author <a href="http://charles.karney.info/">Charles Karney</a>
<charles@karney.com>
\version 2007-05
\date 2007-05-21

\section abstract Abstract

RandomLib is a C++ interface to the Mersenne Twister random number
generator,
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">
MT19937</a>.  It provides convenient access to random integers and reals
at a variety of precisions.  The emphasis in this implementation is on
providing a reliable source of random numbers for scientific
applications where there's a premium on accuracy, repeatability,
portability, and ease of use.  This library provides an improved method
for seeding the generator with arrays and it allows access to both the
32- and 64-bit versions of MT19937.

This library also supports the SIMD-oriented Fast Mersenne Twister
random number generator,
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">
SFMT19937</a>.

\section download Download

The code is available for download at
http://charles.karney.info/random/Random.tgz

It is licensed under the LGPL.  For more information, see
http://charles.karney.info/random/

\section contents Contents
 - \ref intro
 - \ref example
 - \ref organization
 - \ref seeds
 - \ref integer
 - \ref real
   - \ref fixed
   - \ref floating
   - \ref reals
 - \ref other
 - \ref otherdist
 - \ref save
 - \ref programming
   - \ref conversion
   - \ref stl
   - \ref misc
   - \ref sfmt
   - \ref bit64
   - \ref timing
 - \ref parallel
   - \ref leapfrog
 - \ref function
 - \ref old

<center>
Forward to \ref intro.
</center>

**********************************************************************/
/**
\page intro Introduction

<center>
Forward to \ref example.  Up to \ref contents.
</center>

Random is a C++ class which implements the Mersenne Twister random
number generator,
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">
MT19937</a>.  See \n
<a href="mailto:m-mat@math.sci.hiroshima-u.ac.jp">Makoto Matsumoto</a> and
Takuji Nishimura,\n
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf">
Mersenne Twister: A 623-Dimensionally Equidistributed Uniform
Pseudo-Random Number Generator</a>,\n
<a href="http://dx.doi.org/10.1145/272991.272995">
ACM TOMACS 8, 3--30 (1998)</a>,\n
MT19937 is a high-quality random number generator with an exceptionally
large period 2<sup>19937</sup> - 1 or about 10<sup>6001</sup>; it passes
all current tests for randomness.

The library was written by <a href="http://charles.karney.info/">Charles
Karney</a> <charles@karney.com> and is licensed under the LGPL.  For
more information, see http://charles.karney.info/random/  The code is
available for download at
http://charles.karney.info/random/Random.tgz

The emphasis in this implementation is on providing a reliable source
of random numbers for scientific applications where there's a premium
on
- accuracy --- all the results from Random are exact assuming that
  MT19937 is a perfect random number generator.  Thus a random integer
  in [0, \e n) is given by Integer(\e n) which guarantees that all
  possible results are equally likely.  Similarly FloatN() is equivalent
  to sampling a random number in (0,1) and exactly rounding it to the
  nearest representable double.
- repeatability --- extensive facilities for managing the seed for the
  generator.  It's easy to seed the generators in a parallel application
  in a systematic way to give repeatable results.
- portability --- the same results are obtained on different platforms.
- efficiency --- template functions provide fast general code.
- ease of use --- the interface makes it difficult to misuse the
  generator with most usage errors being caught at compile time.

Random provides the basic functionality of the MT19937 random generator,
converting the random data into various formats.  It provides methods
for returning random integers of various sizes (short int, int, long
int, etc.), for returning random integers in the semi-closed interval
[0,\e n) and the closed interval [\e m,\e n].

You can obtain uniform random reals at various precisions; these are
defined by rounding an random number uniformly sampled in (0,1) and
exactly rounding it (down, up, or nearest) to a subset of representable
reals.  Thus Float() is the result of rounding a random number in (0,1)
down to the nearest representable double.

Boolean() returns true with probability 1/2.  Prob(\e x) returns true
with probability \e x.  Prob(\e a, \e b) returns true with probability
<i>a</i>/\e b.

Bits<\e n>() returns \e n bits of randomness in a bitset<\e n>.

All the results from Random are \e exact under the assumption that the
underlying random generator is perfect.

In addition, Random provides facilities for setting seeds, for selecting
a "random" seed, for saving and restoring its state, and for jumping the
generator forwards and backwards.

Finally, NormalDistribution and ExponentialDistribution are classes
which sample from the normal and exponential distributions.
RandomSelect selected from an arbitrary discrete distribution.

My interest in random number generators extends back through much of my
professional career in plasma physics, chaos theory, and computational
chemistry.  I wrote a random number library for Fortran 77 and Fortran
90 which implemented one of Knuth's recommended random number generators
(see http://w3.pppl.gov/ntcc/RNG/).  With the current C++ random number
library, I switched to a more robust underlying generator, MT19937,
provided more flexible seeding options, and provided exact
implementations for uniform real and integer distributions.

In the 2007-05 version of this library, support for the SIMD-oriented
Fast Mersenne Twister random number generator,
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">
SFMT19937</a>, was introduced.  See\n
<a href="mailto:saito@math.sci.hiroshima-u.ac.jp">Mutsuo Saito</a>,\n
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf">
An Application of Finite Field: Design and Implementation of 128-bit
Instruction-Based Fast Pseudorandom Number Generator</a>,
\n Master's Thesis, Dept. of Math., Hiroshima University (Feb. 2007),\n
<a href="mailto:saito@math.sci.hiroshima-u.ac.jp">Mutsuo Saito</a> and
<a href="mailto:m-mat@math.sci.hiroshima-u.ac.jp">Makoto
Matsumoto</a>,\n
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf">
SIMD-oriented Fast Mersenne Twister: a 128-bit Pseudorandom Number
Generator</a>,\n
accepted in the proceedings of MCQMC2006

This is discussed in \ref sfmt.

<center>
Forward to \ref example.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page example Example

<center>
Back to \ref intro.  Forward to \ref organization.  Up to \ref contents.
</center>

The following gives a quick idea of the capabilities of the library.
Note that the classes are all defined in the RandomLib namespace.
\code
  #include "RandomLib/Random.hpp"

  unsigned u; unsigned long long l;
  float f; double d; long double e; bool b;
  RandomLib::Random r;
  std::cout << "Seed set to: " << r.SeedString() << std::endl;

  f = r.FixedU<float>();      // result in (0,1] with 24 bits of randomness
  d = r.Fixed();              // result in [0,1) with 53 bits of randomness
  e = r.FixedN<long double>(); // result in [0,1] with 64 bits of randomness
  d = r.FloatN();   // a random in [0,1] rounded to the nearest double
  u = r.Integer();            // a random unsigned in [0,2^32)
  l = r.Integer<unsigned long long>(); // a random unsigned long long
  u = r.Integer<16>();        // a random unsigned in [0,2^16)
  u = r.Integer(52U);         // a random unsigned in [0,52)
  u = r(52);     // the same, enables passing r to std::random_shuffle
  u = r.IntegerC(1,6);        // a random integer in [1,6]
  b = r.Boolean();            // true with prob 1/2
  b = r.Prob(4, 7);           // true with prob 4/7
  b = r.Prob(0.34);           // true with prob 0.34

  #include "RandomLib/NormalDistribution.hpp"

  RandomLib::NormalDistribution<> g;
  d = g(r);                   // sample from normal distribution

  #include "RandomLib/ExponentialDistribution.hpp"

  RandomLib::ExponentialDistribution<> x;
  d = x(r);                   // sample from exponential distribution
\endcode

Here is a more fleshed out example.  Compile, link, and run this with,
for example

g++ -I.. -O2 -funroll-loops -o RandomExample RandomExample.cpp Random.cpp\n
./RandomExample

(Note that the -funroll-loops is important!)  This example also
compiles and runs under Windows with Visual C++.

\include RandomExample.cpp

Typical output from this program is:
\verbatim
Seed set to [3114779436]
Estimate pi = 3.1456
Tossing a coin 20 times: HHTTTTTTTTTTTTHHHTTH
Throwing a pair of dice 15 times: 4 3 8 6 4 10 8 10 5 5 4 10 8 9 8
Another 20 throws: 4 8 10 8 9 6 6 11 5 8 3 10 8 4 7 9 7 8 6 6
Draw 5 balls from urn containing 5 red and 5 white balls: WRRWW
Shuffling the digits 0..9: 6458923701
Estimate mean and variance of normal distribution: -0.00699907, 1.02025
Some low precision reals (1/16):  0.6875 0.4375 0.375 0.0625 0.0625
Used 94940 random numbers
Self test of RandomLib::MT19937 32-bit Version 4 passed
Self test of RandomLib::MT19937 64-bit Version 4 passed
Self test of RandomLib::SFMT19937 32-bit Version 0 passed
Self test of RandomLib::SFMT19937 64-bit Version 0 passed
\endverbatim

<center>
Back to \ref intro.  Forward to \ref organization.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page organization Code organization

<center>
Back to \ref example.  Forward to \ref seeds.  Up to \ref contents.
</center>

The capabilities of Random was provided by this hierarchy of classes:

 - RandomSeed.  This provides facilities for managing the seed and for
   converting the seed into random generator state.  For more details
   see \ref seeds.

 - MT19937.  This is derived from RandomSeed.  Template parameters
   determine the choice of the 32-bit and 64-bit Mersenne Twister
   algorithms for advancing the state for generating random data.  It
   also provides facilities for stepping the generator and for saving
   and restoring its state.

 - SFMT19937.  This is derived from RandomSeed and implements the 32-bit
   and 64-bit SFMT generators.

 - RandomGenerator is a typedef for MT19937<u32, 32u> (which gives the
   standard 32-bit version of MT19937).  See \ref bit64 for how to
   access the 64-bit version.  See \ref sfmt for how to access the
   SFMT19937 generators.

 - RandomCanonical.  This accepts a random generator as a template
   parameter and is a derived class of that generator.  RandomCanonical
   converts the random bits from the underlying generator into usable
   data: integers in specific ranges, real numbers at various
   resolutions, etc.

 - Random is a typedef for RandomCanonical<RandomGenerator>.

For most purposes, users should ignore the existence of RandomSeed,
RandomGenerator/MT19937/SFMT19937, and RandomCanonical and access all
the capabilities of these classes via thru the class Random which
inherits all the functionality of its bases classes.  This documentation
reflects this recommendation.  (In restricted applications, a user might
wish to interface to the library via the lower-level RandomGenerator
class.)

Unfortunately the relation between this classes is sufficiently
complicated to defeat doxygen's indexing capabilities; if you need to
look up the definition of one of Random's member functions, you can
refer to the brief index in \ref function.

Finally, distributions such as the normal and exponential distribution
are provided by the classes NormalDistribution and
ExponentialDistribution.  They access the random data by being passed a
Random object as an argument to operator().

These routines have been developed and tested with g++ version 3.4.x and
4.x under Linux 2.6.x on 32-bit Intel and 64-bit AMD CPUs and MS Visual
C++ 7.x under Windows 2000.  Some testing has also been carried out with
g++ on 64-bit SPARC platforms.  Porting to other platforms with a
standard C++ compiler and template library should be straightforward
provided that the radix for integer and real types is 2.

(g++ 3.3.x cannot handle the overloaded template definitions properly.
Contact me for possible workarounds for this version of g++.)

<center>
Back to \ref example.  Forward to \ref seeds.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page seeds The seed

<center>
Back to \ref organization.  Forward to \ref integer.  Up to \ref contents.
</center>

The state of MT19937 is given by a set of 19937 bits.  Over the course
of the period of the generator all possible states are visited.  (The
state consisting of all zeros is disallowed.)  Thus the sequence
consists of \e X<sub><i>i</i></sub> where \e X<sub><i>i</i> +
<i>L</i></sub> = \e X<sub><i>i</i></sub> and \e L = 2<sup>19937</sup> -
1.  When using the generator we need to specify a starting state \e j so
that the sequence is then \e Y<sub><i>i</i>; <i>j</i></sub> = \e
X<sub><i>i</i> + <i>j</i></sub>

However, rather than specified an unwieldy set of 19937 bits, we instead
specify a vector \e s of integers.  These integers are cast to unsigned
longs and only the low 32 bits of result are used.  The length of \e s
is arbitrary (it can even be zero), however in most applications, its
length will be small --- often a length of 1 provides sufficient "seed
space".  The process of seeding MT19937 consists of manipulating the \e
s in some "complicated" way to provide the necessary starting state \e
j.  Thus the random sequence is now viewed as \e Z<sub><i>i</i>;
<i>s</i></sub> = \e Y<sub><i>i</i>; <i>j</i>(<i>s</i>)</sub> = \e
X<sub><i>i</i> + <i>j</i>(<i>s</i>)</sub>.

Now the user's view of a typical random number generator is that \e
Z<sub><i>i</i>; <i>s</i></sub> and \e Z<sub><i>i</i>; <i>s</i>'</sub>
are \e independent provided \e s and \e s' are distinct.  A necessary
condition for independence is that |\e j(\e s) - \e j(\e s')| > \e R
where \e R is the maximum number of random numbers needed for a
particular seed.  If we assume that the seeding function \e j(\e s)
produces randomly distributed starting positions and if maximum number
of seeds we might use is \e S, then the probability of overlapping
sequences, i.e., that |\e j(\e s) - \e j(\e s')| < \e R for some \e s
and \e s' is \e S<sup>2</sup>\e R / \e L.

Suppose we take \e R = 10<sup>200</sup> and \e S = 10<sup>100</sup>,
then the probability of overlap is a tiny 10<sup>-5600</sup>.  (On the
other hand with rand() for which the period \e L is 2<sup>32</sup>, we
have an appreciable probability of overlap with \e R = 2000 and \e S =
1000.)  This means that we can safely assume that the sequences \e
Z<sub><i>i</i>; <i>s</i></sub> as independent and this then means that
from the user's perspective the most useful representation of the state
of the generator is [\e i, \e s] which is given by [Count(), Seed()].

It's frequently desirable to start each run of a code with a different
"arbitrary" seed.  The current time (in seconds) is frequently used for
this purpose.  However, if many runs are starts simultaneously, they are
likely to use the same seed.  Random::SeedWord() can instead be called.
This returns an unsigned long generated from various sources
(/dev/urandom, the microsecond clock, etc.).  The default constructor
for Random sets the seed to the vector [Random::SeedWord()].

Because Random::SeedWord() returns a result in [0, 2<sup>32</sup>),
there's a strong probability of collisions after 2<sup>16</sup>
invocations.  If you expect that your code will be invoked more often
than that, then instead use Random::SeedVector() to seed the generator.
This returns a vector of unsigned longs which is almost certainly
unique.  However successive calls to Random::SeedVector() may return the
same result.  If multiple random number sequences are required, for
example in a multi-threaded application, then Random::SeedVector() can
be called once by the master thread to define a master seed and each
slave thread would set its seed to a vector obtained by appending a
thread index to the master seed.

Whenever random numbers are used it is important to record the seed
used.  Without this information, it will be impossible to repeated
(e.g., to track down a bug).  Random::SeedString() returns
the seed vector as a string allowing it to be printed on standard
output easily.  Thus
\code
  RandomLib::Random r;   // sets seed to [Random::SeedWord()]
  std::cout << "Random seed set to " << r.SeedString() << std::endl;
\endcode

In general, the seed may be set either with the constructor or with
Reseed(...).  If you expect to have to reseed a Random object prior to
using it, instantiate it with Random(unsigned long) to avoid the
overhead of the call to Random::SeedWord(); for example
\code
  RandomLib::Random r(0);
  if (debug)
    r.Reseed(1234);  // sets seed to [1234]
  else
    r.Reseed();      // sets seed to [Random::SeedWord()]
  std::cout << "Random seed set to " << r.SeedString() << std::endl;
\endcode

There are several ways to set the seed to a vector.  For example the
seed can be set to [1,2,3,4] via Reseed as follows
\code
  RandomLib::Random r(0);
  r.Reseed("[1,2,3,4]");        // via a string
  unsigned v[] = {1,2,3,4};
  r.Reseed(v, v+4);             // via iterators
  r.Reseed(vector<unsigned>(v, v+4)); // via vector
\endcode
The seed may be similarly set via constructors of Random.

The original C interface for the Mersenne Twister provided two
seed-setting interfaces: (a) init_genrand, which took a single unscaled
long as argument and (b) init_by_array, which took an array (length > 0)
of unsigned longs as an argument.  Thus, the set of allowed seeds was
{\e a, [\e a], [\e a, \e b], [\e a, \e b, \e c], ...}, where \e a and
[\e a] were distinct.  But this then presents a confusing interface to
the user.  In addition, it's not clear how best to report back the seed
to the user.

In this implementation, seeds are always vectors (of arbitrary length,
including zero).  Thus the set of allowable seeds is {[], [\e a], [\e a,
\e b], [\e a, \e b, \e c], ...}  which is easily and unambiguously
represented by the STL vector container.  Note also that [], [0], [0,
0], etc. are all distinct as are [\e a], [\e a, 0], [\e a, 0, 0].
Seeding with Reseed(\e n) merely sets the seed to a vector of length
one, [\e n].

The method for converting the seed into the random generator state for
the 32-bit version of MT19937 is given by in Brown, et al.,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf">
Random Number Generation in C++0X: A Comprehensive Proposal, version
3</a>.  This is a modification of the
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c">
mt19937ar implementation</a>.  That implementation have some defects
- some simple seeds, e.g., [1] and [1,0], gives the same state;
- one bit of the state vector is unconditionally set to one;
- the length of the seed vector could not be zero

These defects have been cured in this implementation.  The same fixes
have been applied to the array seeding method given by the
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/C-LANG/mt19937-64.c">
mt19937-64 implementation</a> to provide the seeding algorithm the
64-bit version of MT19937.  Unfortunately, the result is that the
present seeding scheme is incompatible with the original
implementations.  However seeding with the empty vector, Reseed(""), is
equivalent to the "default" seed of the earlier implementations.

SFMT19937 uses a seeding method which is considerably improved over that
of MT19937.  This is adapted from the init_by_array in SFMT.c in the
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/SFMT-src-1.2.tar.gz">
SFMT implementation</a>.

<center>
Back to \ref organization.  Forward to \ref integer.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page integer Random integers

<center>
Back to \ref seeds.  Forward to \ref real.  Up to \ref contents.
</center>

The following routines return random integers of the given type
uniformly distributed in [min, max].  These are member functions of
Random.

<center>
<table>
<caption>Definitions of routines returning integers</caption>
<tr>
  <th>routine
  <th>type
  <th>min
  <th>max
<tr>
  <td>Integer<IntType, b>()
  <td>IntType
  <td>0
  <td>2<sup><i>b</i></sup> - 1
<tr>
  <td>Integer<b>()
  <td>unsigned
  <td>0
  <td>2<sup><i>b</i></sup> - 1
<tr>
  <td>Integer();
  <td>unsigned
  <td>0
  <td>std::numeric_limits<unsigned>::max()
<tr>
  <td>Integer<IntType>()
  <td>IntType
  <td>std::numeric_limits<IntType>::min()
  <td>std::numeric_limits<IntType>::max()
<tr>
  <td>Boolean()
  <td>bool
  <td>false
  <td>true
<tr>
  <td>Integer<IntType>(IntType \a n)
  <td>IntType
  <td>0
  <td>\a n - 1\n
  (if \a n == 0, std::numeric_limits<IntType>::max();\n
   if \a n < 0, 0)
<tr>
  <td>IntegerC<IntType>(IntType \a n)
  <td>IntType
  <td>0
  <td>\a n \n
  (if \a n < 0, 0)
<tr>
  <td>IntegerC<IntType>(IntType \a m, IntType \a n)
  <td>IntType
  <td>\a m
  <td>\a n \n
  (if \a n < \a m, \a m)
<tr>
  <td>operator()()
  <td>Random::result_type
  <td>0
  <td>2<sup><i>w</i></sup> - 1
<tr>
  <td>operator()(result_type n)
  <td>Random::result_type
  <td>0
  <td>\a n - 1\n(if \a n == 0, std::numeric_limits<result_type>::max())
</table>
</center>
Here \a w = Random::width.  For the default random generator,
result_type is an unsigned int and \a w = 32.

<center>
Back to \ref seeds.  Forward to \ref real.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page real Random real numbers

<center>
Back to \ref integer.  Forward to \ref other.  Up to \ref contents.
</center>

The Random class generates two classes of uniform real results: \ref
fixed "fixed" point numbers (where the spacing between possible results
is a constant) and \ref floating "floating" point numbers (where the
spacing between possible results varies).

\section fixed Fixed-point real numbers

The results returned by Fixed(), FixedU(), FixedN(), FixedW(), FixedO(),
and FixedC() are "fixed-point reals" with precision \e p.  These are of
the form \e i / 2<sup><i>p</i></sup> where \e i is an integer.  If, for
real data type RealType, we restrict \e p > 0 and \e p <=
std::numeric_limits<RealType>::digits, then all such numbers in [-1,1]
are representable.  For \e p = 3, the set of numbers in [0,1] is {0,
1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1}.

The results returned FixedS() are of "offset fixed-point reals" with
precision \e p.  These are of the form (\e i + 1/2) /
2<sup><i>p</i></sup> where \e i is an integer.  If, for real data type
RealType, we restrict \e p > 0 and \e p <=
std::numeric_limits<RealType>::digits, then all such numbers in
(-1/2,1/2) are representable.  (This only "works" for radix 2 systems;
with larger bases, the results can't be represented exactly.)  Note that
possibly "exceptional" numbers, -1/2, 0, and 1/2, are not included in
this set.  For \e p = 3, the set of numbers in (-1/2,1/2) is {-7/16,
-5/16, -3/16, -1/16, 1/16, 3/16, 5/16, 7/16}.

\section floating Floating-point real numbers

The results returned by Float(), FloatU(), FloatN(), FloatW() are
"floating-point reals" with precision \e p and exponent range \e e.  The
possible results for such floating numbers in [-1,1] consist of
 - \e f / 2<sup><i>p</i> + <i>s</i></sup> for \e f in (2<sup><i>p</i> -
   1</sup>, 2<sup><i>p</i></sup>] and \e s in [0,\e e],
 - \e f / 2<sup><i>p</i> + <i>s</i></sup> for \e f in
   [-2<sup><i>p</i></sup>, -2<sup><i>p</i> - 1</sup>) and \e s in [0,\e
   e],
 - \e f / 2<sup><i>p</i> + <i>e</i></sup> for \e f in
   [-2<sup><i>p</i> - 1</sup>, 2<sup><i>p</i> - 1</sup>].

For real data type RealType, such numbers are representable if
 - \e p > 0
 - \e e >= 0
 - \e p <= std::numeric_limits<RealType>::digits
 - \e p + \e e <= std::numeric_limits<RealType>::digits -
   std::numeric_limits<RealType>::min_exponent

For \e e = 0, the numbers become the \ref fixed "fixed" point numbers
with precision \e p.

Here is an example of the floating point points with \e p = 3 and \e e =
2 together with the probabilities yielded by Float(), FloatU(),
FloatN().

<center>
<table>
<caption>Floats with \e p = 3, \e e = 2</caption>
<tr><td>\e X
    <td>prob(Float() = \e X)
    <td>prob(FloatU() = \e X)
    <td>prob(FloatN() = \e X)
<tr><td>   0   <td>      1/32  <td>   0    <td>     0.5/32
<tr><td>   1/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   2/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   3/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   4/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   5/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   6/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   7/32<td>      1/32  <td>   1/32 <td>      1/32
<tr><td>   4/16<td>      1/16  <td>   1/32 <td>     1.5/32
<tr><td>   5/16<td>      1/16  <td>   1/16 <td>      1/16
<tr><td>   6/16<td>      1/16  <td>   1/16 <td>      1/16
<tr><td>   7/16<td>      1/16  <td>   1/16 <td>      1/16
<tr><td>   4/8 <td>      1/8   <td>   1/16 <td>     1.5/16
<tr><td>   5/8 <td>      1/8   <td>   1/8  <td>      1/8
<tr><td>   6/8 <td>      1/8   <td>   1/8  <td>      1/8
<tr><td>   7/8 <td>      1/8   <td>   1/8  <td>      1/8
<tr><td>   1   <td>      0     <td>   1/8  <td>     0.5/8
</table>
</center>

The description of floating-point numbers assumes that the underlying
hardware supports denormalized numbers.  This is the case with most
modern computers.  The code attempts to deal also with older hardware
where there's a gap between 0 and 1/2<sup><i>e</i> + 1</sup>, but this
has not been tested.

\section reals Summary of real number routines

The following table provides a succinct definition of each of the member
functions of Random routines that return a real result.  Here \e u is a
uniformly distributed random number in (0,1).  This is drawn from a
continuous distribution; i.e., it may be thought of as consisting of a
binary point followed by an infinite sequence of random binary bits.
(This is just a useful conceptual framework.  None of the
implementations of these functions require an explicit realization of \e
u.)

The term "fixed" means a fixed-point real with precision \e p, and we
have \e h = 1/2<sup><i>p</i></sup> (the smallest positive fixed-point
number).  The term "float" means a floating-point real with precision \e
p and exponent range \e e.

<center>
<table>
<caption>Definitions of routines returning reals</caption>
<tr>
  <th>routine
  <th>mnemonic
  <th>definition
<tr>
  <td>Fixed()
  <td>default (down)
  <td>round \e u down to previous fixed
<tr>
  <td>FixedU()
  <td>upper
  <td>round \e u up to next fixed
<tr>
  <td>FixedN()
  <td>nearest
  <td>round \e u to nearest fixed
<tr>
  <td>FixedW()
  <td>wide
  <td>round 2\e u - 1 to nearest fixed
<tr>
  <td>FixedS()
  <td>symmetric
  <td>round \e u - 1/2 to nearest offset fixed
<tr>
  <td>FixedO()
  <td>open
  <td>round (1 - \e h)\e u up to nearest fixed
<tr>
  <td>FixedC()
  <td>closed
  <td>round (1 + \e h)\e u down to nearest fixed
<tr>
  <td>Float()
  <td>default (down)
  <td>round \e u down to previous float
<tr>
  <td>FloatU()
  <td>upper
  <td>round \e u up to next float
<tr>
  <td>FloatN()
  <td>nearest
  <td>round \e u to nearest float
<tr>
  <td>FloatW()
  <td>wide
  <td>round 2\e u - 1 to nearest float
</table>
</center>

The precision and exponent range are determined as follows.  Each of
the fixed-point routines comes in 3 variants, for example,
 - Fixed<RealType,p>() --- return fixed-point real of type RealType,
   precision \e p;
 - Fixed<RealType>() --- as above with \e p =
   std::numeric_limits<RealType>::digits;
 - Fixed() --- as above with RealType = double.

Similarly each of the floating-point routines comes in 3 variants, for
example,
 - Float<RealType,p,e>() --- return floating-point real of type
   RealType, precision \e p, exponent range \e e;
 - Float<RealType>() --- as above with \e p =
   std::numeric_limits<RealType>::digits and \e e =
   -std::numeric_limits<RealType>::min_exponent;
 - Float() --- as above with RealType = double.

Typical values of digits and min_exponent are given by
<center>
<table>
<caption>Typical parameters for real types</caption>
<tr>
  <th>type
  <th>digits
  <th>-min_exponent
<tr>
  <td>float            <td>24     <td>125
<tr>
  <td>double           <td>53     <td>1021
<tr>
  <td>long double      <td>64     <td>16381
<tr>
  <td>long double (Sun)<td>113    <td>16494
</table>
</center>

In the following tables, the columns have the following meanings
 - "min" and "max" give the bounds on the
returned results;
 - "num" gives the number of distinct
results;
 - "prob" gives the probability of each result.

next(X) is the next representable float following X.
prev(X) is the previous representable float preceding X.

<center>
<table>
<caption>Properties of routines returning reals</caption>
<tr>
  <th>routine
  <th>min
  <th>max
  <th>num
  <th>prob
<tr>
  <td>Fixed()
  <td>0
  <td>1-<i>h</i>
  <td>2<sup><i>p</i></sup>
  <td><i>h</i>
<tr>
  <td>FixedU()
  <td><i>h</i>
  <td>1
  <td>2<sup><i>p</i></sup>
  <td><i>h</i>
<tr>
  <td>FixedN()
  <td>0
  <td>1
  <td>2<sup><i>p</i></sup> + 1
  <td><i>h</i> (<i>h</i>/2 at endpoints)
<tr>
  <td>FixedW()
  <td>-1
  <td>1
  <td>2<sup><i>p</i>+1</sup> + 1
  <td><i>h</i>/2 (<i>h</i>/4 at endpoints)
<tr>
  <td>FixedS()
  <td>-(1-<i>h</i>)/2
  <td>(1-<i>h</i>)/2
  <td>2<sup><i>p</i></sup>
  <td><i>h</i>
<tr>
  <td>FixedO()
  <td><i>h</i>
  <td>1-<i>h</i>
  <td>2<sup><i>p</i></sup>-1
  <td><i>h</i>/(1-<i>h</i>)
<tr>
  <td>FixedC()
  <td>0
  <td>1
  <td>2<sup><i>p</i></sup>+1
  <td><i>h</i>/(1+<i>h</i>)
<tr>
  <td>Float()
  <td>0
  <td>1-<i>h</i>
  <td>2<sup><i>p</i></sup>(1+<i>e</i>/2)
  <td>min(1,next(<i>X</i>))-<i>X</i>
<tr>
  <td>FloatU()
  <td>1/2<sup><i>p</i>+<i>e</i></sup>
  <td>1
  <td>2<sup><i>p</i></sup>(1+<i>e</i>/2)
  <td><i>X</i>-max(0,prev(<i>X</i>))
<tr>
  <td>FloatN()
  <td>0
  <td>1
  <td>2<sup><i>p</i></sup>(1+<i>e</i>/2)+1
  <td>(min(1,next(<i>X</i>))-max(0,prev(<i>X</i>)))/2
<tr>
  <td>FloatW()
  <td>-1
  <td>1
  <td>2<sup><i>p</i>+1</sup>(1+<i>e</i>/2)+1
  <td>(min(1,next(<i>X</i>))-max(-1,prev(<i>X</i>)))/4
</table>
</center>

From these definitions, we can show that:
- probability(Fixed() < \e X) = \e X) for all representable
  fixed-point numbers \e X in [0,1];
- probability(Float() < \e X) = \e X) for all representable
  floating-point numbers \e X in [0,1];
- probability(FixedU() <= \e X) = \e X) for all representable
  fixed-point numbers \e X in [0,1];
- probability(FloatU() <= \e X) = \e X) for all representable
  floating-point numbers \e X in [0,1];
- probability(FixedN() < \e X) = \e X) for all \e X in (0,1)
  midway between representable fixed-point numbers \e X in [0,1];
- probability(FloatN() < \e X) = \e X) for all \e X in (0,1)
  midway between representable floating-point numbers \e X in [0,1].

We can easily show that certain distributions are equivalent:
<center>
<table>
<caption>Equivalences between routines returning reals</caption>
<tr>
  <th>Function
  <th>Equivalent
<tr>
  <td>FixedU<RealType,p>()
  <td>Fixed<RealType,p>() + h
<tr>
  <td>FixedU<RealType,p>()
  <td>1 - Fixed<RealType,p>()
<tr>
  <td>FixedN<RealType,p>()
  <td>Boolean() ? Fixed<RealType,p>() : FixedU<RealType,p>()
<tr>
  <td>FixedN<RealType,p>()
  <td>1 - FixedN<RealType,p>()
<tr>
  <td>FixedO<RealType,p>()
  <td>1 - FixedO<RealType,p>()
<tr>
  <td>FixedC<RealType,p>()
  <td>1 - FixedC<RealType,p>()
<tr>
  <td>FixedS<RealType,p>()
  <td>Fixed<RealType,p>() - (1-h)/2
<tr>
  <td>FixedS<RealType,p>()
  <td>- FixedS<RealType,p>()
<tr>
  <td>FixedW<RealType,p>()
  <td>(Boolean() ? 1 : -1) FixedN<RealType,p>()
<tr>
  <td>FixedW<RealType,p>()
  <td>- FixedW<RealType,p>()
<tr>
  <td>FixedW<RealType,p-1>()
  <td>2 FixedN<RealType,p>() - 1
<tr>
  <td>FloatN<RealType,p,e>()
  <td>Boolean() ? Float<RealType,p,e>() : FloatU<RealType,p,e>()
<tr>
  <td>FloatW<RealType,p,e>()
  <td>(Boolean() ? 1 : -1) FloatN<RealType,p,e>()
<tr>
  <td>FloatW<RealType,p,e>()
  <td>- FloatW<RealType,p,e>()
<tr>
  <td>Float<RealType,p,0>()
  <td>Fixed<RealType,p>()
<tr>
  <td>FloatU<RealType,p,0>()
  <td>FixedU<RealType,p>()
<tr>
  <td>FloatN<RealType,p,0>()
  <td>FixedN<RealType,p>()
<tr>
  <td>FloatW<RealType,p,0>()
  <td>FixedW<RealType,p>()
</table>
</center>

A caution about FixedO() and FixedC().  All four of
FixedS(), FixedN() - 0.5, FixedO() - 0.5, and
FixedC() - 0.5 produce results which are strictly symmetric
about 0 and would thus be suitable for an unbiased random walk.  The
variances of the first two distributions are 1/12 +
O(<i>h</i><sup>2</sup>), close to the ideal value.  On the other hand
the variances of the distributions of FixedO() and
FixedC() are 1/12 + O(\e h), significantly further from the
ideal value.  (In practice, using a strictly symmetric normal
distribution is preferable for simulating a random walk.)

Similarly, consider estimating the value of pi by randomly selecting
points in a unit square and determining what fraction lie in a circle of
diameter 1.  Sampling in the square using FixedO() or
FixedC() gives poorer results than FixedN(), and
FixedS() gives slightly better results.

Because of their definitions in terms of \e u, any of Fixed(),
FixedU(), FixedN(), or FixedS() can be used to
cover the periodic unit interval in an unbiased way.  Thus to sample an
angle uniformly, use 2.0 * M_PI * Fixed() or 2.0 * M_PI *
FixedS().  The latter has the advantage that it is strictly
symmetric about zero.  In addition, angles which are multiples of pi/2
are avoided (which may obviate the need to check for special cases).

Usually, these real routines would be invoked by specifying the type and
allowing the precision to be determined from the type, e.g.,
Real<double>().  However, in some cases it might be useful to
specify a lower precision:
 - to match the precision on another platform and thereby to ensure
   portability, e.g., Real<double, 48>() to match the precision
   of the Cray 1 computers.
 - for debugging to explore boundary cases or to allow a thorough
   exploration of possible results, e.g., Real<real, 4>().
 - to control rounding errors, e.g.,
   1.0 + Real<double, 52>() samples the doubles in [1, 2)
   uniformly (while 1.0 + Real<double>() does not).
 - for economy, e.g., Real<double, 32>() consumes 1 random
   number from RandomGenerator instead of 2.  (This is the weakest
   reason.  The overall speedup is likely to be small; and, in any case,
   accuracy should trump speed.)

<center>
Back to \ref integer.  Forward to \ref other.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page other Other random results

<center>
Back to \ref real.  Forward to \ref otherdist.  Up to \ref contents.
</center>

The following routines return true with the given probability

<center>
<table>
<caption>Definitions of routines returning booleans</caption>
<tr>
  <th>routine
  <th>probability
<tr>
  <td>Boolean()
  <td>1/2
<tr>
  <td>Prob<NumericType>(NumericType p)
  <td>\a p
<tr>
  <td>Prob<NumericType>(NumericType m, NumericType n)
  <td><i>m</i>/<i>n</i>
</table>
</center>

Prob accepts both real and integer types.  However, typically the
one-argument version (the Bernoulli distribution) would be used with a
real argument and the two-argument version would be used with integer
arguments.  Prob<NumericType>(NumericType p) is false if \a p <= 0 and
true if \a p >= 1.  Prob<NumericType>(NumericType m, NumericType n)
returns false if \a m <= 0 or \a n < 0 and true if \a m >= \a n.  The
results of Prob are \e exact.  In particular, Prob<double>(x, y) returns
true with probability <i>x</i>/<i>y</i> even if <i>x</i>/<i>y</i> cannot
be exactly represented as a double (e.g., it underflows to zero).

<center>
<table>
<caption>Equivalences between routines returning booleans</caption>
<tr>
  <th>Function
  <th>Equivalent
<tr>
  <td>Boolean()
  <td>Integer<bool>()
<tr>
  <td>Boolean()
  <td>Prob(1, 2)
<tr>
  <td>Boolean()
  <td>Prob(0.5)
<tr>
  <td>Prob<RealType>(x)
  <td>Float<RealType>() < x
<tr>
  <td>Prob<RealType>(x)
  <td>FloatU<RealType>() <= x
</table>
</center>

Finally, Bits<n>() returns \a n random bits in a std::bitset<n>.

<center>
Back to \ref real.  Forward to \ref otherdist.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page otherdist Other random distributions

<center>
Back to \ref other.  Forward to \ref save.  Up to \ref contents.
</center>

This library includes implementation of a few other random distributions
- RandomLib::NormalDistribution samples from a Gaussian.  This uses the
  ratio method with Leva's modifications to avoid computing logarithms
  too frequently.
- RandomLib::ExponentialDistribution samples from an exponential
  distribution.  This is uses FloatU to avoid log(0) and to allow rare
  large values to be returned.
- RandomLib::RandomSelect selects for a discrete set with specified
  weights using the Walker algorithm.  With integer weights this is an
  exact implementation.
- RandomLib::LeadingZeros returns the number of zero bits after the
  binary point of a uniform random number in (0,1).  This is exact.
- RandomLib::ExponentialProb returns true with probability exp(-\e p)
  using von Neumann's algorithm.  This is exact.

These provide fast, reasonably accurate (or, where noted, exact)
implementations of these distributions.

In general, it is difficult to sample from an distribution and round the
result exactly to the nearest representable real number.  However, for
some simple distributions, the exact distribution is given by a series
of uniform distributions and this provides a method for sampling
exactly.  The class which represents the result of sampling from such
distributions is RandomLib::RandomNumber.  It can be thought of as an
infinite precision random number.  At any time only some of the leading
digits have been computed and the result then stands for any number
obtained by filling in the remaining digits uniformly and randomly.  The
following are distributions with return a RandomNumber
- RandomLib::ExactExponential samples exactly from an exponential
  distribution.  The surprisingly simple algorithm is due to von Neumann
  but adapted here to use infinite precision.
- RandomLib::ExactPower samples exactly from a power distribution
  (<i>n</i> + 1) <i>x</i><sup><i>n</i></sup> for \e x in (0,1) and
  integer \e n >= 0.

No attempt has been to optimize these exact distributions for speed.
However, with base = 2, ExactExponential delivers \e k bits of accuracy
consuming, on average, only about 8 + \e k bits of randomness; so a fast
implementation is possible.  (Similarly it's possible to return true
with probability 1/\e e consuming 6 bits of randomness.)

The following code samples from the exponential distribution, rounding
the results exactly to the nearest double.  Thus the probability that
0.75 is returned is exactly 2 exp(-3/4) sinh(2<sup>-54</sup>) (with no
error in the evaluation of exp and sinh).  (This assumes, of course,
that the underlying random number generator is perfect.)
\code
  RandomLib::Random r;
  const int b = 32;
  RandomLib::ExactExponential<b> edist;
  for (size_t i = 0; i < 10; ++i) {
    RandomLib::RandomNumber<b> x = edist(r);  // Sample exactly
    double y = x.Value<double>(r); // Round exactly to nearest double
    std::cout << y << std::endl;
  }
\endcode

<center>
Back to \ref other.  Forward to \ref save.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page save Saving and restoring the state

<center>
Back to \ref otherdist.  Forward to \ref programming.  Up to \ref contents.
</center>

A Random can be copied, saved, and restored in a variety of
ways as illustrated here.
\code
  #if HAVE_BOOST_SERIALIZATION
  // With some versions of boost, these includes need to precede the
  // inclusion of RandomLib/Random.hpp
  #include <boost/archive/xml_iarchive.hpp>
  #include <boost/archive/xml_oarchive.hpp>
  #endif

  #include "RandomLib/Random.hpp"

  unsigned long l = 0;
  double d = 0;
  bool b = false;
  RandomLib::Random r;
  std::cout << "Seed set to: " << r.SeedString() << std::endl;
  d += r.Fixed();               // use r

  // Saving and restoring with a copy of r
  RandomLib::Random s(r);       // copy r's state into s via copy constructor
  l += r.Integer();             // use r some more
  r = s;               // restore r's state from s via copy assignment

  // Saving and restoring with Count()
  long long c = r.Count();      // save position in r's stream
  b ^= r.Boolean();             // use r
  r.SetCount(c);                // restore r from saved count

  // Saving and restoring to file
  {
    std::ofstream f("rand.bin", std::ios::binary);
    r.Save(f);                  // save r in binary mode to rand.bin
  }
  {
    std::ifstream f("rand.bin", std::ios::binary);
    s.Load(f);                  // load saved state to s
  }
  // Saving as text
  {
    std::ofstream f("rand.txt");
    f << "Random number state:\n" << r << std::endl; // operator<<
  }
  #if HAVE_BOOST_SERIALIZATION
  // Saving and restoring the state using boost serialization
  {
    std::ofstream f("rand.xml");
    boost::archive::xml_oarchive oa(f);
    oa << BOOST_SERIALIZATION_NVP(r);   // save r to xml file rand.xml
  }
  {
    std::ifstream f("rand.xml");
    boost::archive::xml_iarchive ia(f);
    ia >> BOOST_SERIALIZATION_NVP(s);   // load saved state to s
  }
  #endif
  // Initializing with copy or modification of seed
  s.Reseed(r.Seed());           // s reseeded with r's seed
  {
    std::vector<unsigned long> v(r.Seed());
    v.push_back(1);
    s.Reseed(v);                // s reseeded with 1 appended to r's seed
  }
\endcode

As you can see in this example, you can use Boost serialization to save
and restore the state of a Random object to various types of archives
provided you have the Boost serialization library installed (see
http://www.boost.org).  To turn this feature on, compile any code which
includes RandomLib/Random.hpp with HAVE_BOOST_SERIALIZATION defined to
be 1, and link the resulting code with libboost_serialization.  In order
to declare the boost archives, you will need to include the appropriate
header file, e.g.,
\code
  #include <boost/archive/xml_iarchive.hpp>
  #include <boost/archive/xml_oarchive.hpp>
\endcode
With some versions of Boost, it is apparently necessary for these
includes to precede the inclusion of Randomlib/Random.hpp.

<center>
Back to \ref otherdist.  Forward to \ref programming.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page programming Programming tips

<center>
Back to \ref save.  Forward to \ref parallel.  Up to \ref contents.
</center>

\section conversion Conversion from std::rand()

Here are simple steps to convert a code using rand() to Random:
- Change \#include &lt;cstdlib&gt; to \#include "RandomLib/Random.hpp".
- Change std::srand(unsigned int) to
  RandomLib::Random::Global.Reseed(unsigned long); change
  std::srand(time(0)) to RandomLib::Random::Global.Reseed().  (Reseed()
  uses a more "random" seed than the current time in seconds.)
- As a stop-gap, change std::rand() to RandomLib::Random::Global() and
  change RAND_MAX to RandomLib::Random::max.  Preferably, you should see
  how std::rand() is being used and substitute the appropriate member
  function of Random.  For example:
 - To obtain a random real in [0,1), change
   double(std::rand())/(RAND_MAX + 1.0) to
   RandomLib::Random::Global.Fixed<double>().
 - To generate a random real in (0,1], to avoid a singularity at 0, use
   RandomLib::Random::Global.FixedU<double>().
 - To generate a real symmetrically distributed in (-1/2,1/2), use
   RandomLib::Random::Global.FixedS<double>().
 - To obtain a random integer in [0,n), change int(n *
   double(std::rand())/(RAND_MAX + 1.0)) to
   RandomLib::Random::Global.Integer(n).
 - To select a random integer in [m,n], use
   RandomLib::Random::Global.IntegerC(m,n).
- Change std::random_shuffle(first, last) to std::random_shuffle(first,
  last, RandomLib::Random::Global).
- Change std::generate(first, last, std::rand) to pass
  RandomLib::Random::Global by reference.  See section on using the \ref
  stl "standard template library".

These examples use Random::Global which is a globally defined Random
object.  In many cases this suffices.  However, if different parts of
your code need independent random number streams, you can create your
own Random objects.  In these cases, you might want to vary the seeds
used to initialize the separate streams in a systematic way and, in that
case, you can seed Random with a vector.  When you pass Random objects
to other routines you should usually (always?) pass them by reference,
Random&, to ensure that that the change in the state of the generator is
seen by the parent routine.

\section stl Interaction with the standard template library

Do not pass a Random object to std::generate to fill an vector with
random integers.  Even though operator()() is defined to produce an
random integer in [0,2<sup>32</sup>), generate makes a \e copy of its
operator argument.  Thus
\code
  RandomLib::Random r;
  std::vector<unsigned> a(10);
  std::vector<unsigned> b(10);
  std::generate(a.begin(), a.end(), r);
  std::generate(b.begin(), b.end(), r);
\endcode
results in \e a and \e b having the same contents and r.Count() == 0.
You should instead pass the Random object by reference as in
\code
  std::generate<std::vector<unsigned>::iterator, RandomLib::Random&>
    (a.begin(), a.end(), r);
  std::generate<std::vector<unsigned>::iterator, RandomLib::Random&>
    (b.begin(), b.end(), r);
\endcode
Alternatively (and more flexibly) you can define function objects which
accept the Random by reference in the constructor as follows:
\code
template<typename IntType = int> class RandomInteger {
private:
  RandomLib::Random& _r;
  const IntType _m, _n;
public:
  RandomInteger(RandomLib::Random& r, IntType m, IntType n)
    : _r(r), _m(m), _n(n) {}
  IntType operator()() { return _r.IntegerC<IntType>(_m, _n); }
};

template<typename RealType = double> class RandomNormal {
private:
  RandomLib::Random& _r;
  const RandomLib::NormalDistribution<RealType> _n;
  const RealType _mean, _sigma;
public:
  RandomNormal(RandomLib::Random& r,
               RealType mean = RealType(0), RealType sigma = RealType(1))
    : _r(r), _n(RandomLib::NormalDistribution<RealType>())
    , _mean(mean), _sigma(sigma) {}
  RealType operator()() { return _n(_r, _mean, _sigma); }
};
\endcode
Now, you can use
\code
  RandomLib::Random r;
  std::vector<int> a(10);     // Fill with integers in [-10,10]
  std::generate(a.begin(), a.end(), RandomInteger<>(r,-10,10));
  std::vector<double> b(10);       // Fill with normal deviates
  std::generate(b.begin(), b.end(), RandomNormal<>(r,1.0,2.0));
\endcode

On the other hand, std::random_shuffle does pass its operator argument by
reference.  Thus a vector can be shuffled with
\code
  RandomLib::Random r;
  std::vector<unsigned> a(100);
  for (unsigned i = 0; i < 100; ++i)
    a[i] = i;
  // create a random permutation of [0,100)
  std::random_shuffle(a.begin(), a.end(), r);
\endcode
This shuffles because operator()(unsigned n) is defined to produce an
random integer in [0,\e n).  This shuffling can result in all possible
permutations of vectors of lengths up to 2000 (because 2000! <
2<sup>19937</sup>), whereas the built-in random number generator
(invoked when the last argument to random_shuffle is omitted) can
typically only produce all the permutations of 12 or fewer objects.

\section misc Miscellaneous

When saving the state of a program in a restart file, it is usually only
necessary to save only the Random objects with Save(...).  (In fact,
Random contains no additional state beyond the state of RandomGenerator.
And thus Save just calls the underlying RandomGenerator::Save.)

RandomSelect has state which is derivable from its input weights.
However, neither it nor the other distributions contain state which
depends on the Random argument to operator()(Random& r) (which is a
const member function).

For speed and for better control over round-off errors, the real
routines FixedX are preferred over FloatX.  In a few cases, FloatX gives
better results, e.g., in the implementation of ExponentialDistribution
where it provides finer granularity in the results.

Fixed, FixedU, FixedN, FixedW, FixedS are all obtained by rounding an
ideal uniform deviate and so can all be used to sample periodic
intervals uniformly.  If possible, avoid using FixedC and FixedO since
they can introduce bias into your simulations.  Instead of FixedC,
consider FixedN.  Instead of FixedO, consider FixedU (to avoid 0) or
shift interval to (-1/2,1/2) and use FixedS.  You can also generate
results in (0,1) by invoking FixedS with a smaller precision and
shifting the result, for example
\code
  RandomLib::Random r;
  double y =              // result in (0,1)
    r.FixedS<double, std::numeric_limits<double>::digits - 1>() + 0.5;
\endcode

This library defines a STATIC_ASSERT to check template parameters and
the values of some constants at compile time.  For example, this will
prevent you from requesting 100 bits of accuracy in a float, e.g.,
Fixed<float,100>().  The error message you get from the compiler
may not be very informative.  However if you look at the corresponding
line of source code in the header file, you should be able to figure out
the problem.

\section sfmt The SFMT19937 generator.

The SIMD-oriented
Fast Mersenne Twister random number generator,
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">
SFMT19937</a> is described in\n
<a href="mailto:saito@math.sci.hiroshima-u.ac.jp">Mutsuo Saito</a>,\n
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/M062821.pdf">
An Application of Finite Field: Design and Implementation of 128-bit
Instruction-Based Fast Pseudorandom Number Generator</a>,
\n Master's Thesis, Dept. of Math., Hiroshima University (Feb. 2007),\n
<a href="mailto:saito@math.sci.hiroshima-u.ac.jp">Mutsuo Saito</a> and
<a href="mailto:m-mat@math.sci.hiroshima-u.ac.jp">Makoto Matsumoto</a>,\n
<a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/sfmt.pdf">
SIMD-oriented Fast Mersenne Twister: a 128-bit Pseudorandom Number
Generator</a>,\n
accepted in the proceedings of MCQMC2006

This is related to the MT19937 generator and shares most of its
properties.  The advantages are
 - SFMT19937 can be implemented efficiently on a machine supporting SSE2
   instructions.
 - The 32- and 64-bit versions of the algorithm are essentially the same
   (the underlying algorithm manipulates 128-bit words).
 - The scheme for converting the seed to the initial state does a better
   job of mixing the seed.
 - SFMT19937 recovered from a state with a preponderance of 0s more
   quickly (this is unlikely to occur in practice).
 - SFMT19937 has better equidistribution properties.  But this is
   unlikely to be observatable.

The chief reservation about using it is that it doesn't (yet!) have the
same track record as MT19937.

This implementation includes a portable one which will work fine on all
binary computers, and an implementation using SSE2 instructions.  SSE2
support is detected automatically on Linux platforms by the supplied
Makefile.  On Windows, there's an "SSE2" configuration that enables SSE2
support.  No support is provided for the AltiVec instruction set,
because I don't have a machine on which to test it.

RandomLib provides 8 typdefs:
 - MRandomGenerator32 = MT19937<u32, 32u>, the 32-bit version of MT19937;
 - MRandomGenerator64 = MT19937<u64, 64u>, the 64-bit version of MT19937;
 - SRandomGenerator32 = SFMT19937<u32, 32u>, the 32-bit version of SFMT19937;
 - SRandomGenerator64 = SFMT19937<u64, 64u>, the 64-bit version of SFMT19937;
 - MRandom32 = RandomCanonical<MRandomGenerator32>;
 - MRandom64 = RandomCanonical<MRandomGenerator64>;
 - SRandom32 = RandomCanonical<SRandomGenerator32>;
 - SRandom64 = RandomCanonical<SRandomGenerator64>;

Normally, 4 additional typedefs are provided
 - RandomGenerator32 = MRandomGenerator32;
 - RandomGenerator64 = MRandomGenerator64;
 - Random32 = MRandom32;
 - Random64 = MRandom64;

However if USE_SFMT is defined, these are changed to
 - RandomGenerator32 = SRandomGenerator32;
 - RandomGenerator64 = SRandomGenerator64;
 - Random32 = SRandom32;
 - Random64 = SRandom64;

Finally, by default, we define
 - RandomGenerator = RandomGenerator32;
 - Random = Random32;

to provide access to the 32-bit version of MT19937 (if USE_SFMT is not
defined) or SFMT19937 (if USE_SFMT is defined).

\section bit64 Using the 64-bit versions of MT19937 and SFMT19937

There are two implementations of MT19937 provided here, the original
32-bit version (which is the default) and a 64-bit version.  The latter
generator manipulates the state as a set of 64-bit words and produces
64-bits of randomness with a call to operator()().  The two versions of
MT19937 produce \e different sequences; however, the implementations of
each version are portable across 32-bit and 64-bit architectures.

You can access either version via Random32 or Random64 (or with the
lower-level RandomGenerator32 or RandomGenerator64).  In the default
compilation Random and RandomGenerator are typedef'ed to Random32 and
RandomGenerator32.  However you can hook these up to the 64-bit versions
by defining MTPREC64 when compiling files which include Random.hpp.
This can be down by supplying -DMTPREC64 on the command line for the
compiler or by specifying the value when invoking make, e.g., make
MTPREC64=1 RandomExample.

Because the two versions of MT19937 are of comparable strength, The main
criterion for deciding which version to use is the performance.  A
glance at the timing data in the \ref timing "next section" shows that
the 64-bit version is 1-3 times \e slower than the 32-bit version on a
32-bit architecture (i686) and is about the same speed on a 64-bit
machine (x86_64).  However on a 64-bit machine, random routines which
can consume 64-bits random results in one piece, e.g.,
r.Integer<unsigned long long>() and r.Fixed<double>, are about twice as
fast with Random64 (and r() is the same speed but produces twice as many
random bits).

Thus some narrow applications (those using mainly random double results
and running exclusively on 64-bit machines) might benefit from using
Random64.  However, in practice, the resulting speed advantage might be
small because the generator of random numbers represents a small part of
the overall code.  So even in these cases, you might prefer to use
Random32.

I recommend against using the Random32 in one part of your code and
Random64 in another.  This will merely result in a more complicated
code.

\section timing Timing results

The following times were obtained on Linux systems running Fedora Core
4, kernel version 2.6.16, and compiling with g++ version 4.0.2 with
optimization flags "-O3 -funroll-loops -finline-functions
-fomit-frame-pointer".  The random objects {M,S}Random{32,64} are here
abbreviated {MT,SFMT}{32,64}.  Here \a r is a Random object, \a n is a
unsigned variable with value 0 (but the compiler doesn't know its
value), \a N is a large positive integer, and all times are in ns
(unless another time unit is given)

<center>
<table>
<caption>Times (ns) for various operations</caption>
<tr><th rowspan="2">operation</th>
<th colspan="4">Pentium III, i686, 864MHz
</th><th colspan="4">AMD Opteron, x86_64 2GHz (SSE2)</th></tr>
<tr><th>MT32</th><th>MT64</th><th>SFMT32</th><th>SFMT64</th>
<th>MT32</th><th>MT64</th><th>SFMT32</th><th>SFMT64</th></tr>
<tr><td>std::rand()
</td><td colspan="4"> 89.7</td><td colspan="4"> 14.7</td></tr>
<tr><td>r()
</td><td>   24.6</td><td>   66.6</td><td>   23.3</td><td>   40.6
</td><td>    7.9</td><td>    8.0</td><td>    3.4</td><td>    5.2</td><td>
<tr><td>r.Integer<unsigned>()
</td><td>   24.8</td><td>   66.4</td><td>   22.7</td><td>   41.4
</td><td>    7.9</td><td>    8.2</td><td>    3.4</td><td>    5.1</td><td>
<tr><td>r.Integer<unsigned long long>()
</td><td>   53.4</td><td>   68.3</td><td>   51.9</td><td>   43.8
</td><td>   16.2</td><td>    8.1</td><td>    7.2</td><td>    5.1</td><td>
<tr><td>r.Integer<unsigned,6>()
</td><td>   25.9</td><td>   67.2</td><td>   23.2</td><td>   42.7
</td><td>    8.5</td><td>    8.5</td><td>    3.5</td><td>    5.2</td><td>
<tr><td>r.Integer<unsigned>(52u)
</td><td>   35.7</td><td>   73.6</td><td>   28.8</td><td>   49.0
</td><td>   10.6</td><td>   10.6</td><td>    6.3</td><td>    8.0</td><td>
<tr><td>r.Integer<unsigned>(52u+n)
</td><td>  102.7</td><td>  146.1</td><td>  112.3</td><td>  129.3
</td><td>   52.9</td><td>   55.3</td><td>   48.1</td><td>   48.9</td><td>
<tr><td>r.Fixed<float>()
</td><td>   48.8</td><td>   97.8</td><td>   49.0</td><td>   76.4
</td><td>   10.8</td><td>   11.7</td><td>    6.8</td><td>    8.6</td><td>
<tr><td>r.Fixed<double>()
</td><td>   95.8</td><td>   96.1</td><td>   98.3</td><td>   76.0
</td><td>   20.0</td><td>   11.6</td><td>   11.1</td><td>    8.0</td><td>
<tr><td>r.Float<float>()
</td><td>  101.1</td><td>  172.7</td><td>   92.5</td><td>  139.8
</td><td>   37.7</td><td>   38.0</td><td>   28.9</td><td>   31.4</td><td>
<tr><td>r.Float<double>()
</td><td>  150.3</td><td>  173.1</td><td>  149.4</td><td>  139.9
</td><td>   49.4</td><td>   40.5</td><td>   36.0</td><td>   34.2</td><td>
<tr><td>r.Prob<float>(0.28f)
</td><td>   71.3</td><td>  115.3</td><td>   64.4</td><td>   88.3
</td><td>   22.5</td><td>   23.0</td><td>   16.3</td><td>   17.8</td><td>
<tr><td>r.Prob<double>(0.28)
</td><td>   68.6</td><td>  113.3</td><td>   65.5</td><td>   89.2
</td><td>   21.9</td><td>   22.9</td><td>   15.5</td><td>   17.0</td><td>
<tr><td>NormalDistribution<float>()(r)
</td><td>  257.3</td><td>  387.9</td><td>  255.7</td><td>  328.7
</td><td>   74.1</td><td>   78.0</td><td>   57.0</td><td>   64.4</td><td>
<tr><td>NormalDistribution<double>()(r)
</td><td>  380.2</td><td>  386.3</td><td>  386.5</td><td>  330.5
</td><td>   99.9</td><td>   78.1</td><td>   72.3</td><td>   62.8</td><td>
<tr><td>SeedWord()
</td><td colspan="4"> 6.4 ms</td><td colspan="4"> 1.6 ms</td></tr>
<tr><td>SeedVector()
</td><td colspan="4">  82 us</td><td colspan="4">  13 us</td></tr>
<tr><td>r.Reset(), r()
</td><td>  45 us</td><td>  49 us</td><td>  64 us</td><td>  66 us
</td><td> 9.6 us</td><td> 5.5 us</td><td colspan="2">10.7 us</td><td>
<tr><td>r.StepCount(N)
</td><td>  8.1 N</td><td> 36.1 N</td><td> 16.9 N</td><td> 34.3 N
</td><td>  3.1 N</td><td>  3.0 N</td><td>  1.8 N</td><td>  3.5 N</td><td>
<tr><td>r.StepCount(-N)
</td><td> 13.2 N</td><td> 41.1 N</td><td> 18.7 N</td><td> 39.2 N
</td><td>  4.3 N</td><td>  4.5 N</td><td>  3.0 N</td><td>  6.1 N</td><td>
</table>
</center>

Loop unrolling is critical in the performance of, e.g., Fixed<double>().
If your compiler doesn't unroll the loops in Fixed<RealType,p>(), you
can provide specializations with the loops unrolled by hand.  The time
quoted for r.Reset(), r() gives the time to reseed the generator and
to obtain the first random result.

Much of the speed of this implementation comes from extensive use of
inlined procedures.  This also make the timing results sensitive to the
context in which Random is called.  Compare the results for
r.Integer<unsigned>(52u) (typical if drawing a card from a deck) and
r.Integer<unsigned>(52u+n) (as typical called by std::random_shuffle).
In the first case the compiler can precompute some of the variables used
resulting is a much faster execution.  The best way of gauging the speed
is to time or to profile your own application.

Beware of the compiler optimizing too much code away when doing timing
studies.  Timing this section of code
\code
  RandomLib::Random r;
  const size_t n = 100000000;
  for (size_t i = n; i; --i) r.Fixed<double>();
\endcode
will usually result is an unrealistically short time (by a factor of \e
three!) because the compiler skips over a lot of the computation (the
tempering of the random results and all the real multiplications).  You
can prevent the compiler from "cheating" in this way by using the
results from the timed functions.  Thus
\code
  RandomLib::Random r;
  const size_t n = 100000000;
  double d = 0;
  for (size_t i = n; i; --i) d += r.Fixed<double>();
  std::cout << "Sum: " << d << std::endl;
\endcode
More simply, you can  store the results in a variable which is declared
volatile
\code
  RandomLib::Random r;
  const size_t n = 100000000;
  volatile double d;
  for (size_t i = n; i; --i) d = r.Fixed<double>();
\endcode
As of 2006-11-03, at least one implementor of the Mersenne Twister makes
a bogus speed claim for his implementations because of a poorly designed
timing test:
 - <a href="http://www-personal.engin.umich.edu/~wagnerr/MersenneTwister.html">
   MersenneTwister-1.0</a> by <a href="mailto:rjwagner@writeme.com">
   Rick Wagner</a> (problem reported to author on 2005-10-17).

There's nothing the matter with this implementation.  It's just that it
isn't as fast as claimed.

<center>
Back to \ref save.  Forward to \ref parallel.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page parallel Parallelization

<center>
Back to \ref programming.  Forward to \ref function.  Up to \ref contents.
</center>

Many large codes are designed to run in parallel environments.  Each
program thread then needs its own private Random which needs to
be uniquely seeded.  In a message passing environment the code would
look  like
\code
  // Parallel code where each thread gets a unique seed
  RandomLib::Random r(0);             // Thread local Random
  std::vector<unsigned long> seed;    // Thread local seed
  if (comm.Id() == 0) {               // On master node
    if (debug)
      seed.push_back(314159265UL);
    else
      seed = RandomLib::Random::SeedVector();
    logfile << "Master seed: " << RandomLib::Random::VectorToString(seed)
            << std::endl;
    comm.Send(slaveIds, seed);       // Send seed to slaves
  } else                             // On slave nodes
    comm.Receive(seed);              // Receive seed from master
  seed.push_back(comm.Id());         // Make seed unique to this process
  r.Reseed(seed);                    // Reseed Random
  ...                                // The work goes here
\endcode

This approach has the disadvantage that the results of the code will
depend on the number of processors (assuming that debug is true, so that
the master seed is fixed).  If your code divides the computation out
amongst the threads in a way that depends on how quickly each thread
completes a unit of work, then the results will vary from run to run
even with a fixed number of threads.  This is a huge problem when
developing a code: debugging a multi-threaded code is difficult enough;
debugging a code where the results aren't repeatable just increases the
difficulty.  The solution is to require that the results be independent
of the number of processors.  This would allow the algorithms and basic
code to be debugged with a non-parallel version of the code.  When
moving to the parallel version, we require that the results stay the
same, and any deviation from this signals a bug in the parallelization.
This can be accomplished by having the seed depend on the the data
(e.g., a loop index) rather than on processor.  Here's how this might be
done:
\code
  // Parallel code where each loop iteration gets a unique seed
  RandomLib::Random r(0);                        // Thread local Random
  std::vector<unsigned long> seed;    // Thread local seed
  if (comm.Id() == 0) {
    // On master node
    if (debug)
      seed.push_back(314159265UL);
    else
      seed = RandomLib::Random::SeedVector();
    logfile << "Master seed: " << RandomLib::Random::VectorToString(seed)
            << std::endl;
    comm.Send(slaveIds, seed);       // Send seed to slaves
  } else
    comm.Receive(seed);              // Receive seed from master
  seed.push_back(0);                 // Increase the seed size by 1
  // Num units are work are to be divided between nproc processes.
  // Assume comm.Id() is in [0,nproc).
  for (size_t i = 0; i < num; ++i) {
    if (i % nproc != comm.Id())     // Handle this index?
      continue;
    seed.back() = i;                 // Make seed unique to this index
    r.Reseed(seed);                  // Reseed Random
    ...                              // The work goes here
  }
\endcode

This code will satisfy the goal of producing results which are
independent on the number of processors.  However, if \e num is large
(say 10<sup>8</sup>), and if each iteration through the loop consumes
only a small number of random numbers (say, at most, 100).  Then we are
abusing the MT19937 random number generator.  There are two potential
problems.
 - Efficiency: We can see from the following table that reseeding the
   generator is roughly as expensive as consuming 2000 random numbers
   from the generator.
 - Statistical accuracy: A sequence of numbers produced by MT19937 with
   a given seed has some proven good statistical properties.  Little is
   known about the properties of the sequence of numbers obtained when
   MT19937 is frequently reseeded.

<center>
<table>
<caption>Approximate relative times for basic seeding operations</caption>
<tr>
  <th>Function
  <th>Relative time
<tr>
  <td>s = Random::SeedWord();
  <td>200000
<tr>
  <td>v = Random::SeedVector();
  <td>4000
<tr>
  <td>r.Reseed(v); i = r();
  <td>2000
<tr>
  <td>i = r();
  <td>1
<tr>
  <td>r.StepCount(N);
  <td>abs(N)/2
</table>
</center>
In order to address efficiency, we should use at least 10<sup>4</sup>
random numbers for each seed.  In order to preserve the statistical
properties of MT19937, we should consume at least 10<sup>5</sup> random
numbers for each seed.  (Incidentally, this table also shows the high
cost of Random::SeedWord().  This is mainly because of accessing
/dev/urandom.  Typically you should call Random::SeedWord() at most once
per code run.)

A way to ameliorate this problem is to change the loop into a double
loop and do the parallelization and reseeding at the level of the outer
loop.  Here we choose the block size so that maxrandoms * blocksize is
at least 10<sup>5</sup> where maxrandoms is the maximum number of random
numbers consumed per iteration (100 in this example) and blocksize is
the number of iterations in the inner loop.  It's easy to estimate
maxrandoms with calls to Count() at the beginning and end of the
body of the loop.  Thus:
\code
  // Parallel code where each block gets a unique seed
  ...                                // Get the master seed as above
  // Num units are work are to be divided between nproc processes in
  // blocks of size blocksize.
  const size_t blocksize = 1000;
  for (size_t i = 0, j = 0; i < num; ++j) { // j is block index
    if (j % nproc != comm.Id())     // Handle this block?
      continue;
    seed.back() = j;                 // Make seed unique to this block
    r.Reseed(seed);                  // Reseed Random
    do {
      ...                            // A block of work goes here
    } while ((++i) % blocksize && i < num);
  }
\endcode

With this splitting of the code into block you loose some flexibility in
parallelization.  We can overcome this by letting the reseeding be
interspersed with the assignment to processors.  To do this we need an
estimate of the maximum number of random numbers consumed by one
iteration of the inner loop.  We then use SetCount(\e n) to position
the random number sequence to a definite position at the beginning of
each loop.  (We saw in the table above that SetCount is relatively
cheap.)  In this example, we avoid unnecessary reseeding by having a
given processor to deal with a consecutive set of loop iterations.
\code
  // Parallel code where each iteration gets a unique (seed, count)
  ...                                // Get the master seed as above
  // Num units are work are to be divided between nproc processes.
  // Assignment to processes and seeding are treated independently.
  const size_t blocksize = 1000;
  const long long int maxrandoms = 100; // Max # of randoms per loop
  long long int checkmaxrandoms = 0;
  size_t ibeg = (comm.Id() * num)/nproc,  // The index range
         iend = ((comm.Id() + 1) * num)/nproc;
  for (size_t i = ibeg, b = num; i < iend; ++i) { // b is block
    size_t newb = i/blocksize;       // Which block?
    if (newb != b) {                 // in a new block?
      b = newb;
      seed.back() = b;
      r.Reseed(seed);                // then reseed
    }
    size_t k = i % blocksize;        // index within block
    r.SetCount(k * maxrandoms);      // step to starting point
      ...                            // The work goes here
    checkmaxrandoms =                // How many randoms used
      std::max(checkmaxrandoms, r.Count() - k * maxrandoms);
  }
  if (checkmaxrandoms > maxrandoms) {
    ... // flag a warning that maxrandoms needs to be increased
  }
\endcode
If more that maxrandoms numbers are used in a loop, you will have reused
some random numbers and the results should be treated with some
suspicion.  In this case, you should set maxrandoms to, say, double the
value of checkmaxrandoms and try again.  The number of randoms consumed
will usually be normally distributed and it should be easy to pick a
value of maxrandoms which is safe.  Typically, you should adjust
blocksize so that maxrandoms * blocksize lies between 10<sup>5</sup> and
10<sup>7</sup> resulting in a reasonably long sequence of random numbers
per seed.

In the example above, the call to SetCount will typically step the
Random by less than maxrandoms.  On the first iteration of the loop for
a particular process, SetCount might step the Random by as much as
maxrandoms * blocksize = 10<sup>5</sup>; but this typically takes less
than 1 ms on a 2 GHz machine.  So the cost of this strategy will be
small.

There are two other applications where this technique of resetting the
count can be useful.
 - We are running the code on two different platforms were the
   arithmetic operations are done in different orders yielding slightly
   different results.  The concern is at an early iteration of the loop
   will consume one more random number on one platform compared to the
   other (e.g., due to the use of a rejection method in
   NormalDistribution).  This results in a cascade of completely
   different results for the rest of the calculation.  Presumably both
   results are valid.  However, in tracking down bugs, we have wish the
   two versions to stay closer together.  By resetting the count on each
   iteration, we prevent this cascading effect.
 - Correlated sampling is a variance reduction technique where a Monte
   Carlo code is run twice with slightly different parameters in order,
   for example, to determine the change in neutron diffusion as the
   temperature of the moderator varies in a fission reactor.  Such
   calculations are important since they determine the stability of the
   reactor.  Since the results from Monte Carlo codes are intrinsically
   noisy, it's very inaccurate to "numerically differentiate" by running
   the code twice with slightly changed parameters.  With correlated
   sampling the two runs of the code use the same seeds and hence random
   number sequence, so that main component of the noise cancels when
   numerically differentiating.  But here again we would need to
   resynchronize the random number streams, e.g., on the start of each
   neutron flight, in order to avoid a cascading of discrepancies.  In
   this case one or two neutrons may have completely different histories
   (e.g., be captured instead of escaping), but most of the neutrons
   have histories which are close.

\section leapfrog Leapfrogging

In the method described above, the use of SetCount() to reset the
position in the random number stream depends on knowing in advance the
bound on the number of random numbers generated in each iteration of the
loop.  In the absence of this a priori knowledge, we can use
leapfrogging.  In this technique, one iteration through the loop might
use random numbers with indices 30, 40, 50, ..., the next will use 31,
41, 51, ..., and so on.  Consider a program with a compute intensive
loop which we wish to execute in parallel.  Here's the starting code:
\code
  #include "RandomLib/Random.hpp"

  RandomLib::Random r;
  // Use r
  size_t n = 20;
  // The following loop has dependencies through r and cannot be
  // parallelized
  for (size_t i = 0; i < n; ++i) {
    // Use r some more.
  }
  // Use r again
\endcode

We give 3 techniques for removing the dependency:
  - Random number streams with different seeds
  - Block skipping with SetCount()
  - Leapfrogging with SetStride()

Random number streams with different seeds
\code
  #include "RandomLib/Random.hpp"
  #include <vector>

  RandomLib::Random r;
  // Use r
  size_t n = 20;
  {
    // Create independent random number streams.  In this example, each stream
    // will use a unique seed.
    std::vector<RandomLib::Random> s(n, r);
    // The dependencies through r have been eliminated and this loop is now a
    // candidate for parallelization.
    for (size_t i = 0; i < n; ++i) {
      {
        // Base the seed for each new random object on the main seed.
        std::vector<RandomLib::seed_type> seed = s[i].Seed();
        // Add a loop identifier (123 in this example) to the seed, in case
        // several loops need to be parallelizeed with this technique.
        seed.push_back(123);
        // Add a loop index to the seed to make is unique to this iteration
        seed.push_back(i);
        s[i].Reseed(seed);      // Initialize stream with new seed
      }
      // Use s[i] instead of r
    }
  }
  // Use r again
\endcode

Block skipping with SetCount()
\code
  #include "RandomLib/Random.hpp"
  #include <vector>

  RandomLib::Random r;
  // Use r
  size_t n = 20;
  {
    const size_t maxrandom = 1000;
    const long long base = r.Count();
    // Create independent random number streams.  In this example, each stream
    // will use a block of maxrandom consecutive random numbers in base + [i *
    // maxrandom, (i+1) * maxrandom).
    std::vector<RandomLib::Random> s(n, r)
    // The dependencies through r have been eliminated and this loop is now a
    // candidate for parallelization.
    for (size_t i = 0; i < n; ++i) {
      s[i].SetCount(base + i * maxrandom);
      // Use s[i] instead of r
      if (s[i].Count() > base + (i+1) * maxrandom) {
        // Issue a warning that maxrandom is too small
      }
    }
    if (n > 0)
      // s[n-1] is already stepped nearly to the end of the n blocks
      r = s[n-1];
    // Step r past the n blocks.
    r.SetCount(base + n * maxrandom);
  }
  // Use r again
\endcode

Leapfrogging with SetStride()
\code
  #include "RandomLib/Random.hpp"
  #include <vector>

  RandomLib::Random r;
  // Use r
  size_t n = 20;
  {
    // Create independent random number streams.  In this example, each stream
    // will random numbers with indices, base + i + n * [0, 1, 2, 3, ...].
    std::vector<RandomLib::Random> s(n, r);
    // The dependencies through r have been eliminated and this loop is now a
    // candidate for parallelization.
    for (size_t i = 0; i < n; ++i) {
      // Set up leapfrogging
      s[i].SetStride(n, i);
      // Use s[i] instead of r
    }
    // Advance r to the high-water mark of s[i].
    if (n > 0) {
      r = s[0];
      // Turn off leapfrogging
      r.SetStride();
    }
    for (size_t i = 1; i < n; ++i)
      if (s[i].Count() > r.Count())
        r.SetCount(s[i].Count());
  }
  // Use r again
\endcode

Leapfrogging slows down the generation of raw random numbers by a factor
of approximately 1 + (stride - 1)/2.  Thus, in normal use, the stride
should less than 100 or so.  (However this will of course depend on what
other work in done in the loops.)  If the loop count is large, we might
be able to reduce the stride by partially unrolling the loop.
Alternatively, we could replace the loop by a double loop and then the
stride would be the loop count on the inner loop.  The choice of the
strategy will naturally depend on how parallelization is being
implemented.

<center>
Back to \ref programming.  Forward to \ref function.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page function Function index

<center>
Back to \ref parallel.  Forward to \ref old.  Up to \ref contents.
</center>

The relation between Random and its base classes is through template
arguments and this defeats doxygen's indexing capabilities.  Here you
will all the public elements of Random listed together with a more basic
declaration that doxygen can provide a link for.

These problems with doxygen do not extend to the documentation for
distributions for which you can follow the links in \ref otherdist.

Here is the key to the types of the the variables
 - r: RandomLib::Random
 - g, g1, g2: RandomLib::Random (or RandomLib::RandomGenerator)

typedefs and consts
 - Random::seed_type; &nbsp; &nbsp;
   RandomLib::RandomSeed::seed_type
 - Random::result_type; &nbsp; &nbsp;
   RandomLib::RandomGenerator::result_type
 - Random::width; &nbsp; &nbsp;
   RandomLib::RandomGenerator::width
 - Random::min; &nbsp; &nbsp;
   RandomLib::RandomGenerator::min
 - Random::max; &nbsp; &nbsp;
   RandomLib::RandomGenerator::max

Setting and examining the seed
 - Random g(v); &nbsp; &nbsp;
   RandomLib::RandomGenerator::MT19937(const std::vector<IntType>&)
 - Random g(a, b); &nbsp; &nbsp;
   RandomLib::RandomGenerator::MT19937(InputIterator, InputIterator)
 - Random g(n); &nbsp; &nbsp;
   RandomLib::RandomGenerator::MT19937(seed_type)
 - Random g; &nbsp; &nbsp;
   RandomLib::RandomGenerator::MT19937()
 - Random g(s); &nbsp; &nbsp;
   RandomLib::RandomGenerator::MT19937(const std::string&)
 - g.Reseed(v); &nbsp; &nbsp;
   RandomLib::RandomSeed::Reseed(const std::vector<IntType>&)
 - g.Reseed(a,b); &nbsp; &nbsp;
   RandomLib::RandomSeed::Reseed(InputIterator a, InputIterator b)
 - g.Reseed(n); &nbsp; &nbsp;
   RandomLib::RandomSeed::Reseed(seed_type n)
 - g.Reseed(); &nbsp; &nbsp;
   RandomLib::RandomSeed::Reseed()
 - g.Reseed(s); &nbsp; &nbsp;
   RandomLib::RandomSeed::Reseed(const std::string& s)
 - g.Seed(); &nbsp; &nbsp;
   RandomLib::RandomSeed::Seed()
 - g.SeedString(); &nbsp; &nbsp;
   RandomLib::RandomSeed::SeedString()

Static functions for seed management
 - Random::SeedWord(); &nbsp; &nbsp;
   RandomLib::RandomSeed::SeedWord();
 - Random::SeedVector(); &nbsp; &nbsp;
   RandomLib::RandomSeed::SeedVector();
 - Random::VectorToString(v); &nbsp; &nbsp;
   RandomLib::RandomSeed::VectorToString(const std::vector<IntType>&)
 - Random::StringToVector(s); &nbsp; &nbsp;
   RandomLib::RandomSeed::StringToVector(const std::string&)

I/O
 - g.Save(os, bin); &nbsp; &nbsp;
   RandomLib::RandomGenerator::Save(std::ostream&, bool) const
 - g.Load(os, bin); &nbsp; &nbsp;
   RandomLib::RandomGenerator::Load(std::istream&, bool)
 - os << g; &nbsp; &nbsp;
   RandomLib::RandomSeed::operator<<
 - is >> g; &nbsp; &nbsp;
   RandomLib::RandomSeed::operator>>

Functions returning random integers
 - g(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::operator()()
 - r(n); &nbsp; &nbsp;
   RandomLib::RandomCanonical::operator()(result_type n)
 - r.Integer(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Integer()
 - r.Integer(n); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Integer(IntType n)
 - r.IntegerC(n); &nbsp; &nbsp;
   RandomLib::RandomCanonical::IntegerC(IntType n)
 - r.IntegerC(m, n); &nbsp; &nbsp;
   RandomLib::RandomCanonical::IntegerC(IntType m, IntType n)

Functions returning random reals
 - r.Fixed(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Fixed()
 - r.Real(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Real()
 - r.FixedU(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedU()
 - r.FixedN(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedN()
 - r.FixedW(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedW()
 - r.FixedS(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedS()
 - r.FixedO(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedO()
 - r.FixedC(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FixedC()
 - r.Float(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Float()
 - r.FloatU(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FloatU()
 - r.FloatN(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FloatN()
 - r.FloatW(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::FloatW()

Functions returning random booleans
 - r.Boolean(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Boolean()
 - r.Prob(p); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Prob(NumericType)
 - r.Prob(p, q); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Prob(NumericType, NumericType)

Function returning random bits
 - r.Bits<n>(); &nbsp; &nbsp;
   RandomLib::RandomCanonical::Bits<nbits>()

Setting position in sequence
 - g.Count(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::Count()
 - g.SetCount(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::SetCount(long long)
 - g.StepCount(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::StepCount(long long)
 - g.Reset(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::Reset()
 - g.SetStride(n, k); &nbsp; &nbsp;
   RandomLib::RandomGenerator::SetStride(unsigned, unsigned)
 - g.GetStride(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::GetStride()

Other
 - Random::Global; &nbsp; &nbsp;
   RandomLib::Random::Global
 - Random g2(g1); &nbsp; &nbsp;
   default copy constructor
 - g2 = g1; &nbsp; &nbsp;
   default copy assignment
 - g1 == g2; &nbsp; &nbsp;
   RandomLib::RandomGenerator::operator==
 - g1 != g2; &nbsp; &nbsp;
   RandomLib::RandomGenerator::operator!=
 - RandomGenerator::Name(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::Name()
 - RandomGenerator::SelfTest(); &nbsp; &nbsp;
   RandomLib::RandomGenerator::SelfTest()

<center>
Back to \ref parallel.  Forward to \ref old.  Up to \ref contents.
</center>
**********************************************************************/
/**
\page old Old versions

<center>
Back to \ref function.  Up to \ref contents.
</center>

List of versions in reverse chronological order together with a brief
list of changes.

- <a href="http://charles.karney.info/random/Random.tgz">2007-05 (current)</a>
   - Add SFMT19937 generators.
   - Introduce RandomGenerator::Name() to identify generator.
   - Change define used to make 64-bit generator the default.
   - Add RandomSelect::Weight.
   - Ensure portability to systems where RandomSeed::u32 is longer than 32
     bits.

- <a href="http://charles.karney.info/random/Random-2007-04.tgz">2007-04</a>
   - Add utilities RandomPermutation and shuffle.
   - Implement MSB ordering on binary I/O in a portable way.

- <a href="http://charles.karney.info/random/Random-2006-12.tgz">2006-12</a>
   - Add leapfrogging.  The output format needed to be changed to
     accommodate an extra word of data.  However, I/O routines can still
     read the 2006-11 version.

- <a href="http://charles.karney.info/random/Random-2006-11.tgz">2006-11</a>
   - Introduce RandomCanonical class which accepts the random generator
     as a template argument.
   - This allows the inclusion of 32-bit and 64-bit versions of mt19937.
   - Include checksum in I/O.
   - Include boost serialization.

- <a href="http://charles.karney.info/random/Random-2006-10.tgz">2006-10</a>
   - Make 64-bit ready so a 64-bit version of mt19937 can be dropped in.
   - Fix a bug in the seeding.  (This bug was trigged by seed length of
     624 or greater; so it was unlikely to have been encountered in
     practice.)
   - Stop the special case treatment for
     Random::IntegerC<T>(numeric_limits<T>::max()).  In some cases (e.g.,
     T = int) this now gives different (but equivalent) results.

- 2006-09
   - Add ExponentialProb, ExactExponential, ExactPower, and RandomNumber.
   - Fix weakness in the seeding algorithm.  A given seed now gives a
     random sequence different from previous version; so this is an
     incompatible change.
   - Restructure the documentation.
   - Allow constructors to accept vectors of any integral type and
     constructors with a pair of iterators.

- <a href="http://charles.karney.info/random/Random-2006-08.tgz">2006-08</a>
   - Improve efficiency of Integer(n) where n is a power of two.

<center>
Back to \ref function.  Up to \ref contents.
</center>
**********************************************************************/
